## [寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

* **题目：**

  >已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
  >若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
  >若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
  >注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
  >
  >给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
  >
  >你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

* **示例：**

  * **示例1：**

    ```
    输入：nums = [1,3,5]
    输出：1
    ```

  * **示例2：**

    ```
    输入：nums = [2,2,2,0,1]
    输出：0
    ```

  * **提示：**

    * `n == nums.length`
    * `1 <= n <= 5000`
    * `-5000 <= nums[i] <= 5000`
    * `nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转`

* **解析：**

  >一下代码适用于 `寻找旋转排序数组中的最小值 `

* **代码：**

  ```c
  int findMin(int* nums, int numsSize){
      int low = 0, high = numsSize - 1;
      while (low < high){
          int mid = low + (high - low) / 2;
          if (nums[mid] > nums[high]){
              //中间值大于右边界必定是在旋转左边区域
              low = mid + 1;
          }
          else if (nums[mid] < nums[high]){
              //中间值小于左边值必定在右边区域
              high = mid;
          }
          else{
              /*当等于右边的时候无法判断属于哪一个区域
                 可以通过high-1来缩小区间，考虑缩小区间后的几个问题
                 1.越界问题：由于high > low >= 0所以不会越界
                 2.是否会越过最小值：mid是向下取整的，所以mid<high
                  因为nums[mid] == nums[high]所以如果nums[high]是最小值
                  那么当high - 1之后还会存在最小值
              */
              high -= 1;
          }
      }
      return nums[low];
  }
  
  /*以中间值是否大于右边界为参考：不可行：当数组以最外侧元素之外为旋转点，那么元素的顺序将不会改变这一情况该方法不满足，但一右边为参考会满足
  int findMin(int* nums, int numsSize){
      int low = 0, high = numsSize - 1;
      while (low < high){
          int mid = low + (high - low + 1) / 2;
          if (nums[mid] > nums[low]) low = mid; 
          else if (nums[mid] < nums[low]) high = mid; 
          else low += 1;
      }
      return nums[low];
  }
  */
  ```

