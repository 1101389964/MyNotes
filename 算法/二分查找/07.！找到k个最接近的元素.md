## 标题

* **题目：**

  >给定一个 **排序好** 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。
  >
  >整数 `a` 比整数 `b` 更接近 `x` 需要满足：
  >
  >- `|a - x| < |b - x|` 或者
  >- `|a - x| == |b - x|` 且 `a < b`

* **示例：**

  * **示例1：**

    ```
    输入：arr = [1,2,3,4,5], k = 4, x = 3
    输出：[1,2,3,4]
    ```

  * **示例2：**

    ```
    输入：arr = [1,2,3,4,5], k = 4, x = -1
    输出：[1,2,3,4]
    ```

  * **提示：**

    * 1 <= k <= arr.length
    * 1 <= arr.length <= 104
    * arr 按 升序 排列
    * -104 <= arr[i], x <= 10

* **解析：**

  >1. 如果目标 `x` 小于等于有序数组的第一个元素，那么前 `k` 个元素就是答案。
  >
  >2. 类似的，如果目标 `x` 大于等于有序数组的最后一个元素，那么最后 `k` 个元素就是答案。
  >
  >3. 其他情况
  >
  >   用二分法找到最接近目标元素`x`的`index`，令`left = right = index`，然后比较`x-arr[left]`和`arr[right]-x`的大小来选择high++或者low--，
  >   **注意别让low和high越界就可以了**。最后开区间(right,left)内的数就是答案了。

* **代码：**

  ```js
  function findClosestElements(arr, k, x) {  
    //边界判断
    if (arr[0] >= x) return arr.slice(0, k);
    if (arr[arr.length - 1] <= x) return arr.slice(arr.length - k, arr.length);
    // 查找最近目标数 x 的索引
    let left = 0, right = arr.length - 1;
    while (left < right) {
      might = left + (right - left) / 2 >> 0;
      if (arr[might] === x) {
        left = might;
        break;
      }else if (arr[might] < x) {
        left = might + 1;
      }else {
        right = might;
      }
    }
    // 由于left总是向上查找的，所以小于 x 值的会被忽略掉，需要比较取值
    x - arr[left - 1] <= arr[left] - x ? left-- : null;
      
    right = left;
    while (right - left + 1 < k) {
      console.log(left, right);
      if (x - arr[left - 1] <= arr[right + 1] - x) {
        // 如果 left 已经为边界了就不能继续自减了，需要right自加来满足查询到 k 个值
        left === 0 ? (right++) : left--;
      }else {
        right === arr.length - 1 ? left-- : right++;
      }
    }
    return arr.slice(left, right + 1);
  };
  ```