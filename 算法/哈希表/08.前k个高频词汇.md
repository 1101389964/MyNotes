## [前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/)

* **题目：**

  >给定一个单词列表 `words` 和一个整数 `k` ，返回前 `k` 个出现次数最多的单词。
  >
  >返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， **按字典顺序** 排序。
  >

* **示例：**

  * **示例1：**

    ```
    输入: words = ["i", "love", "leetcode", "i", "love", "coding"], k = 2
    输出: ["i", "love"]
    解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
        注意，按字母顺序 "i" 在 "love" 之前。
    ```

  * **示例2：**

    ```
    输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
    输出: ["the", "is", "sunny", "day"]
    解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，
        出现次数依次为 4, 3, 2 和 1 次。
    ```

  * **提示：**

    * `1 <= words.length <= 500`
    * `1 <= words[i] <= 10`
    * `words[i]` 由小写英文字母组成。
    * `k` 的取值范围是 `[1, **不同** words[i] 的数量]`

* **解析：**

  >与上一题相比较，桶的数据不能用数组存放，否则插入新的值复杂度太高，需要用链表存放。

* **代码：**

  ```js
  var topKFrequent = function(numbs, k) {
    const map = new Map();
    const list = new Array(numbs.length + 1).fill(null);
    const res = [];
    for (let i = 0; i < numbs.length; i++) {
        if (map.has(numbs[i])) {
            map.set(numbs[i], map.get(numbs[i]) + 1);
        }else {
            map.set(numbs[i], 1);
        }
    }
    // 桶排序
    map.forEach((value, key) => {
      if (!list[value]) {
        // 可能有相同次数的单词用链表存放，方便插入。
        list[value] = {val: key, next: null};
      }else {
        let before = null;
        let now = list[value];
        const current = {val: key, next: null};
        while (!!now) {
          // 按字典插入排序
          if (now.val > key) {
            current.next = now;
            // 如果前一个结点为空需要把头结点置为current
            if (!before) {
              list[value] = current;
            }else {
              before.next = current;
            }
            break;
          }else if (now.next === null){
            now.next = current;
            break;
          }else {
            before = now;
            now = now.next;
          }
        }
      }
    })
  
    // 倒序查找
    for (let i = numbs.length, j = 0; j < k && i > 0; i--) {
      if (list[i]) {
        let current = list[i];
        while (current !== null && j < k) {
          res.push(current.val);
          current = current.next;
          j++;
        }
      }
    }
    return res;
  };
  ```