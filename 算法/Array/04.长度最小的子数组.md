## 标题

* **题目：**

  >给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。
  >
  >找出该数组中满足其和 `≥ target` 的长度最小的 连续子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。
  >

* **示例：**

  * **示例1：**

    ```
    输入：target = 7, nums = [2,3,1,2,4,3]
    输出：2
    解释：子数组 [4,3] 是该条件下的长度最小的子数组。
    ```

  * **示例2：**

    ```
    输入：target = 4, nums = [1,4,4]
    输出：1
    ```

  * **示例3：**

    ```
    输入：target = 11, nums = [1,1,1,1,1,1,1,1]
    输出：0
    ```

  * **提示：**

    * `1 <= target <= 109`
    * `1 <= nums.length <= 105`
    * `1 <= nums[i] <= 105`

* **解析：**

  >**滑动窗口**。所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。
  ><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组" style="zoom:67%;" />

* **代码：**

  ```js
  var minSubArrayLen = function(target, nums) {
      const len = nums.length;
      let left = 0, right = 0;
      let sum = 0;
      let res = len + 1;
      while(right < len) {
          sum += nums[right];
          // 这里虽然套了一个循环，，但时间复杂度是O(n)，和题目01一样
          while (sum >= target) {
              res = Math.min(res, right - left + 1);
              sum -= nums[left++];
          }
          right++;
      }
      return res === len + 1 ? 0 : res;
  };
  ```