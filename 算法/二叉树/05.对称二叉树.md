## [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

* **题目：**

  >给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

* **示例：**

  * **示例1：**<br>![img](06.对称二叉树.assets/symtree1.jpg)

    ```
    输入：root = [1,2,2,3,4,4,3]
    输出：true
    ```

  * **示例2：**<br>![img](06.对称二叉树.assets/symtree2.jpg)

    ```
    输入：root = [1,2,2,null,3,null,3]
    输出：false
    ```

  * **提示：**

    * 树中节点数目在范围 `[1, 1000]` 内
    * `-100 <= Node.val <= 100`

* **解析：**

  >

* **代码：**

  ```js
  // 层序遍历
  var isSymmetric = function(root) {
      const queue = [];
      queue.push(root);
      while (queue.length) {
          const stack = [];
          for (let i = queue.length; i > 0; i--) {
              const cur = queue.shift();
              const len = stack.length;
              // 当结点不为空将左右子节点放入队列
              if (cur) {
                  queue.push(cur.left);
                  queue.push(cur.right);
              }
              // 将每一个结点都塞入栈
              stack.push(cur);
          }
          let left = 0, right = stack.length - 1;
          while (left <= right) {
              // 当对称结点值相等或者都为null
              if (stack[left] === stack[right] || (stack[left] && stack[right] && stack[left].val === stack[right].val)) {
                  left++;
                  right--;
              }else {
                  return false;
              }
          }
      }
      return true
  };
  
  // 递归
  var isSymmetric = function(root) {
      //使用递归遍历左右子树 递归三部曲
      // 1. 确定递归的参数 root.left root.right和返回值true false 
      const compareNode=function(left,right){
          //2. 确定终止条件 空的情况
          if(left===null&&right!==null||left!==null&&right===null){
              return false;
          }else if(left===null&&right===null){
              return true;
          }else if(left.val!==right.val){
              return false;
          }
          //3. 确定单层递归逻辑
          let outSide=compareNode(left.left,right.right);
          let inSide=compareNode(left.right,right.left);
          return outSide&&inSide;
      }
      if(root===null){
          return true;
      }
      return compareNode(root.left,root.right);
  };
  ```