## [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

* **题目：**

  >给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
  >
  >**有效** 二叉搜索树定义如下：
  >
  >* 节点的左子树只包含 **小于** 当前节点的数。
  >* 节点的右子树只包含 **大于** 当前节点的数。
  >* 所有左子树和右子树自身必须也是二叉搜索树。

* **示例：**

  * **示例1：**<br>![img](17.验证二叉搜索树.assets/tree1.jpg)

    ```
    输入：root = [2,1,3]
    输出：true
    ```

  * **示例2：**<br>![img](17.验证二叉搜索树.assets/tree2.jpg)

    ```
    输入：root = [5,1,4,null,null,3,6]
    输出：false
    解释：根节点的值是 5 ，但是右子节点的值是 4 。
    ```

  * **提示：**

    * 树中节点数目范围在`[1, 104]` 内
    * `-231 <= Node.val <= 231 - 1`

* **解析：**

  >

* **代码：**

  ```js
  // 中序遍历求解
  var isValidBST = function (root) {
      let arr = [];
      // 中序遍历的二叉搜索树必定为递增数组。
      const buildArr = (root) => {
          if (root) {
              buildArr(root.left);
              arr.push(root.val);
              buildArr(root.right);
          }
      }
      buildArr(root);
      for (let i = 1; i < arr.length; ++i) {
          if (arr[i] <= arr[i - 1])
              return false;
      }
      return true;
  };
  
  // 自己作出来的  有些繁琐
  var isValidBST = function(root) {
      let res = true;
      function yesOrNo (root) {
          if (!root) return null;
          // 左边节点的最小值与最大值
          const leftRes = yesOrNo(root.left);
          // 右边节点的最小值与最大值
          const rightRes = yesOrNo(root.right);
          // 若左边节点最大值大于当前值，即不为二叉搜索树
          if (leftRes && root.val <= leftRes[1]) {
              res = res && false;
          }
          // 若右边节点最小值小于当前值，也不为二叉搜索树
          if (rightRes && root.val >= rightRes[0]) {
              res = res && false;
          }
          let min, max;
          if (rightRes && leftRes) {
              min = Math.min(rightRes[0], leftRes[0], root.val);
              max = Math.max(rightRes[1], leftRes[1], root.val);
          }else if (rightRes) {
              min = Math.min(rightRes[0], root.val);
              max = Math.max(rightRes[1], root.val);
          }else if (leftRes) {
              min = Math.min(leftRes[0], root.val);
              max = Math.max(leftRes[1], root.val);
          }else {
              min = root.val;
              max = root.val;
          }
          console.log(min, max);
          // 第一个为以该节点为根节点的最小值，第二个为最大值。
          return [min, max];
      }
      yesOrNo(root);
      return res;
  };
  ```