## [二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

* **题目：**

  >给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。
  >
  >如果树中有不止一个众数，可以按 **任意顺序** 返回。
  >
  >假定 BST 满足如下定义：
  >
  >* 结点左子树中所含节点的值 **小于等于** 当前节点的值
  >* 结点右子树中所含节点的值 **大于等于** 当前节点的值
  >* 左子树和右子树都是二叉搜索树

* **示例：**

  * **示例1：**<br>![img](Untitled.assets/mode-tree.jpg)

    ```
    输入：root = [1,null,2,2]
    输出：[2]
    ```

  * **示例2：**

    ```
    输入：root = [0]
    输出：[0]
    ```

  * **提示：**

    * 树中节点的数目在范围 `[1, 104]` 内
    * `-105 <= Node.val <= 105`

* **解析：**

  >

* **代码：**

  ```js
  var findMode = function(root) {
      // 使用递归中序遍历
      let map = new Map();
      // 1. 确定递归函数以及函数参数
      const traverTree = function(root) {
          // 2. 确定递归终止条件
          if(root === null) {
              return ;
          }
          traverTree(root.left);
           // 3. 单层递归逻辑
          map.set(root.val,map.has(root.val)?map.get(root.val)+1:1);
          traverTree(root.right);
      }
      traverTree(root);
      //上面把数据都存储到map
      //下面开始寻找map里面的
      // 定义一个最大出现次数的初始值为root.val的出现次数
      let maxCount = map.get(root.val);
      // 定义一个存放结果的数组res
      let res = [];
      for(let [key,value] of map) {
          // 如果当前值等于最大出现次数就直接在res增加该值
          if(value === maxCount) {
              res.push(key);
          }
          // 如果value的值大于原本的maxCount就清空res的所有值，因为找到了更大的
          if(value>maxCount) {
              res = [];
              maxCount = value;
              res.push(key);
          }
      }
      return res;
  };
  ```