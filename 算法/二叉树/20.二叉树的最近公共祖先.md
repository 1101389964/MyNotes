## [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

* **题目：**

  >给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
  >
  >[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

* **示例：**

  * **示例1：**<br>![img](20.二叉树的最近公共祖先.assets/binarytree.png)

    ```
    输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输出：3
    解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
    ```

  * **示例2：**<br>![img](20.二叉树的最近公共祖先.assets/binarytree-166323043147610.png)

    ```
    输入：root = [1,2], p = 1, q = 2
    输出：1
    ```

  * **提示：**

    * 树中节点数目在范围 `[2, 105]` 内。
    * `-109 <= Node.val <= 109`
    * 所有 `Node.val` `互不相同` 。
    * `p != q`
    * `p` 和 `q` 均存在于给定的二叉树中。

* **解析：**

  >

* **代码：**

  ```js
  // 注意：p、q是节点并不是节点值，返回值也需要是节点
  /*
  	思路：后序遍历，当节点与目标节点相同则返回true代表该子树一个存在目标值，没找到则返回false;
  	每次返回的结果需要左右子树结果与当前结果去或。只要目标值代表当前结果都有目标值。
  */
  var lowestCommonAncestor = function(root, p, q) {
      let res = null;
      function foo(root, p, q) {
          if (!root) return false;
          const resLeft = foo(root.left, p, q);
          const resRight = foo(root.right, p, q);
         	// 当左右子节点都存在目标值，结果就是该节点，并返回false，回溯并不能再改变res;
          if (resLeft && resRight) {
              res = root;
              return false;
          // 当该节点为目标值，看子树上是否存在目标值，若存在则当前节点就是目标值。否则返回true继续回溯。
          }else if (root === p || root === q) {
              if (resLeft || resRight) {
                  res = root;
                  return false;
              }
              return true;
          }else {
              return false || resLeft || resRight;
          }
      }
      foo(root, p, q);
      return res;
  };
  ```