## [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

* **题目：**

  >给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。
  >

* **示例：**

  * **示例1：**<br><img src="02.从前序与中序遍历序列构造二叉树.assets/tree.jpg" alt="img" style="zoom: 67%;" />

    ```
    输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
    输出: [3,9,20,null,null,15,7]
    ```

  * **示例2：**

    ```
    输入: preorder = [-1], inorder = [-1]
    输出: [-1]
    ```

  * **提示：**

    * `1 <= preorder.length <= 3000`
    * `inorder.length == preorder.length`
    * `-3000 <= preorder[i], inorder[i] <= 3000`
    * `preorder` 和 `inorder` 均 **无重复** 元素
    * `inorder` 均出现在 `preorder`
    * `preorder` **保证** 为二叉树的前序遍历序列
    * `inorder` **保证** 为二叉树的中序遍历序列

* **解析：**

  * **[题解](https://www.programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF)**

* **代码：**

  ```js
  var buildTree = function (preorder, inorder) {
  	if (preorder.length === 0) return null;
      const current = preorder[0]; // 从前序遍历的数组中获取中间节点的值， 即数组第一个值
      const index = inorder.indexOf(current); // 获取中间节点在中序遍历中的下标
      const root = new TreeNode(current); // 创建中间节点
      root.left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index)); // 创建左节点
      root.right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1)); // 创建右节点
      return root;
  };
  ```