## [路径总和](https://leetcode.cn/problems/path-sum/)

* **题目：**

  >给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
  >
  >**叶子节点** 是指没有子节点的节点。

* **示例：**

  * **示例1：**<br>![img](Untitled.assets/pathsum1.jpg)

    ```
    输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
    输出：true
    解释：等于目标和的根节点到叶节点路径如上图所示。
    ```

  * **示例2：**<br>![img](Untitled.assets/pathsum2.jpg)

    ```
    输入：root = [1,2,3], targetSum = 5
    输出：false
    解释：树中存在两条根节点到叶子节点的路径：
    (1 --> 2): 和为 3
    (1 --> 3): 和为 4
    不存在 sum = 5 的根节点到叶子节点的路径。
    ```

  * **示例3：**

    ```
    输入：root = [], targetSum = 0
    输出：false
    解释：由于树是空的，所以不存在根节点到叶子节点的路径。
    ```

  * **提示：**

    * 

* **解析：**

  >

* **代码：**

  ```js
  var hasPathSum = function(root, targetSum) {
      function pathSum(root, cur){
          /*
          	写了很多到二叉树类型的递归，这里总结下 !root 的判断
          	基本每次都需要写 if (!root) 的判断。
          	由于二叉树可能左右节点只有一部分有值，如果每次都判断的特别细，
          	代码的可读性和冗余性都会增加，所以 单独第一行来判断 if (!root) 
          */
          if (!root) return false;
          if (!root.left && !root.right) {
              return root.val + cur === targetSum;
          }
          return pathSum(root.left, cur + root.val) || pathSum(root.right, cur + root.val);
      }
      return pathSum(root, 0);
  };
  ```