```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
```

## 01、前序遍历

* 迭代原理

* 前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

  为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）" style="zoom: 67%;" />

```js
// 迭代
var preorderTraversal = function(root) {
    if (!root) return [];
    // 使用栈存放结点
    const stack = [];
    const res = [];
    stack.push(root);
    while (stack.length) {
        const current = stack.pop();
        res.push(current.val);
        if (current.right) stack.push(current.right);
        if (current.left) stack.push(current.left);
    }
    return res;
};

// 递归
var preorderTraversal = function(root) {
    const res = new Array();
    function preorder(root) {
        if (!root) return;
        res.push(root.val);
        preorder(root.left);
        preorder(root.right);
    }
    preorder(root);
    return res;
};
```

## 02、中序遍历

* 迭代思想<br>![二叉树中序遍历（迭代法）](Untitled.assets/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)

```js
// 迭代
var inorderTraversal = function(root) { 
    // 栈存放前面的结点
    const stack = [];
    const res = [];
    let current = root;
    while (current || stack.length) {
        // 访问节点到最底层
        if (current) {
            stack.push(current); // 将访问的节点放进栈
            current = current.left;
        }else {
            current = stack.pop(); // 从栈里弹出的数据，就是要处理的数据（放进res数组里的数据）
            res.push(current.val);
            current = current.right;
        }
    }
    return res;
}

// 递归 
var inorderTraversal = function(root) {
    const res = [];
    inorder(root);
    function inorder(root) {
        if (!root) return null;
        inorder(root.left);
        res.push(root.val);
        inorder(root.right); 
    }   
    return res;
};
```

## 03、后序遍历

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了。

```js
// 迭代
var postorderTraversal = function(root) {
    if (!root) return [];
    const stack = [];
    const res = [];
    stack.push(root);
    while (stack.length) {
        const current = stack.pop();
        res.push(current.val);
        if (current.left) stack.push(current.left);
        if (current.right) stack.push(current.right);
    }
    return res.reverse();
};

// 递归 
var postorderTraversal = function(root) {
    const res = [];
    postorder(root);
    function postorder(root) {
        if (!root) return null;
        postorder(root.left);
        postorder(root.right); 
        res.push(root.val);
    }   
    return res;
};
```

## 04、层序遍历

```js
var levelOrder = function(root) {
    if (!root) return [];
    // 使用队列存放每一层结点
    const queue = [];
    const res = [];
    queue.push(root);
    while (queue.length) {
        const temp = [];
        // 遍历当前层结点，数量为 queue.length
        for (let i = queue.length; i > 0; i--) {
            const current = queue.shift();
            temp.push(current.val);
            // 将当前结点的左右子结点插入到队列。
            if (current.left) queue.push(current.left);
            if (current.right) queue.push(current.right);
        }
        res.push(temp);
    }
    return res;
};
```