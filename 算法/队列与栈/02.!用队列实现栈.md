## [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

* **题目：**

  >请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
  >
  >实现 `MyStack` 类：
  >
  >* `void push(int x)` 将元素 x 压入栈顶。
  >* `int pop()` 移除并返回栈顶元素。
  >* `int top()` 返回栈顶元素。
  >* `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
  >
  >**注意：**
  >
  >* 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
  >* 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

* **示例：**

  * **示例1：**

    ```
    输入：
    ["MyStack", "push", "push", "top", "pop", "empty"]
    [[], [1], [2], [], [], []]
    输出：
    [null, null, null, 2, 2, false]
    
    解释：
    MyStack myStack = new MyStack();
    myStack.push(1);
    myStack.push(2);
    myStack.top(); // 返回 2
    myStack.pop(); // 返回 2
    myStack.empty(); // 返回 False
    ```

  * **提示：**

    * `1 <= x <= 9`
    * 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
    * 每次调用 `pop` 和 `top` 都保证栈不为空

* **解析：**

  >[题解]([代码随想录 (programmercarl.com)](https://programmercarl.com/0225.用队列实现栈.html))<br><img src="https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈" style="zoom: 80%;" />
  >
  >**优化**
  >
  >其实这道题目就是用一个队列就够了。
  >
  >**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。形成循环队列**

* **代码：**

* **双队列**

  ```js
  var MyStack = function() {
      this.queue1 = [];
      this.queue2 = [];
  };
  
  /** 
   * @param {number} x
   * @return {void}
   */
  MyStack.prototype.push = function(x) {
      this.queue1.push(x);
  };
  
  /**
   * @return {number}
   */
  MyStack.prototype.pop = function() {
      while (this.queue1.length !== 1) {
          this.queue2.push(this.queue1.shift());
      }
      const res = this.queue1.shift();
      while (this.queue2.length !== 0) {
          this.queue1.push(this.queue2.shift());
      }
      return res;
  };
  
  /**
   * @return {number}
   */
  MyStack.prototype.top = function() {
      const x = this.pop();
      this.queue.push(x);
      return x;
  };
  
  /**
   * @return {boolean}
   */
  MyStack.prototype.empty = function() {
      return this.queue1.length === 0;
  };
  ```

* 循环队列

* ```js
  var MyStack = function() {
      this.queue = [];
  };
  
  /** 
   * @param {number} x
   * @return {void}
   */
  MyStack.prototype.push = function(x) {
      this.queue.push(x);
  };
  
  /**
   * @return {number}
   */
  MyStack.prototype.pop = function() {
      let len = this.queue.length;
      while (len !== 1) {
          len--;
          this.queue.push(this.queue.shift());
      }
      return this.queue.shift();
  };
  
  /**
   * @return {number}
   */
  MyStack.prototype.top = function() {
      const x = this.pop();
      this.queue.push(x);
      return x;
  };
  
  /**
   * @return {boolean}
   */
  MyStack.prototype.empty = function() {
      return this.queue.length === 0;
  };
  ```