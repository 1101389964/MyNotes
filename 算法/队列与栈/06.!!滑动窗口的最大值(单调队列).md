## [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

* **题目：**

  >给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
  >
  >返回 *滑动窗口中的最大值* 。

* **示例：**

  * **示例1：**

    ```
    输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
    输出：[3,3,5,5,6,7]
    解释：
    滑动窗口的位置                最大值
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7
    ```

  * **示例2：**

    ```
    输入：nums = [1], k = 1
    输出：[1]
    ```

  * **提示：**

    * `1 <= nums.length <= 105`
    * `-104 <= nums[i] <= 104`
    * `1 <= k <= nums.length`

* **解析：**

  >[题解](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)，题解只需看懂什么是单调队列就好了，上面的js代码不如自己写的好。<br>![239.滑动窗口最大值](06.!!滑动窗口的最大值(单调队列).assets/239.滑动窗口最大值.gif)
  >
  >对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。
  >
  >此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口经行滑动呢？
  >
  >设计单调队列的时候，pop，和push操作要保持如下规则：
  >
  >1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
  >2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，**直到push元素的数值小于等于队列入口元素的数值为止**。

* **代码：**

  ```js
  var maxSlidingWindow = function(nums, k) {
      const len = nums.length;
      // 长度小于窗口值直接返回最大值
      if (len <= k) {
          return [Math.max.apply(Math, nums)];
      }
      const queue = [], res = [];       
      for (let i = 0; i < nums.length; i++) {
          // pop 当单调队列第一个窗口第一个位置前一个数相同说明最大值已经越过需弹出
          if (i >= k && queue[0] === nums[i - k]) {
              queue.shift();
          }
          // push 当前元素小于单调队列最小值需要存下
          if (queue.length === 0 || queue[queue.length - 1] > nums[i]) {
              queue.push(nums[i]);
          }else { // push 大于情况下需要循环，只要单调队列最后一个小于当前值都舍弃。
              while (nums[i] > queue[queue.length - 1]) {
                  queue.pop();
              }
              queue.push(nums[i])
          }
          // 当窗口已经生成后每次将单调队列最大值（也就是第一个）加入结果集
          if (i >= k - 1) {
              res.push(queue[0]);
          }
      }
      return res;
  };
  ```