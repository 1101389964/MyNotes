## **类型推断与保护**

### 交叉类型

交叉类型是使用 `&` 符合将多个类型合并成一个类型。如：`type C = A & B` 这样 `C 类型` 就既有 A 的类型 也有 B 的类型。
常见的如 `Object.assign` 方法，可以将对象进行合并，所以就需要这样的方法将每个对象的类型进行合并，或者说我们在编写 `React` 高阶组件时，编写的过程中就可以对已有类型进行拓展。

注意：**由于是类型合并，所以可能会遇到 2 个类型不兼容的情况，所以如果遇到不兼容的类型就会推导出 `never`。**

```tsx
interface Item1 {
  id: string;
  name: string;
}
interface Item2 {
  id: number;
  age: number;
}

type C = Item1 & Item2;
type Id = C['id'] // never
type Name = C['name'] // string
type Age = C['age'] // number
```

### 联合类型

联合类似是使用 `|` 符合将多个类型联系起来，如：`C = A | B` 表明 `C` 要么等于类型 `A` 要么等于类型 `B`。主要用于当我们一个变量的类型不固定时，比如一个函数运行过程中正常的运算结果返回 `A` ，运算失败返回 `B`。

```tsx
const fn = (num: number): number | string => {
    if (num >=0) {
        return num;
    } else {
        return 'error';
    }
}
const res = fn(1);
```

注意：**当一个值是联合类型时，只可以调用联合类型的共有属性。如上面的 `res` 类型是 `number | string` ，如果不加以判断只能调用共有的 `toString` 和 `valueOf` 等方法。**

----



## **类型推断与保护**

> 正常情况下类型具有自动推断的能力，比如我们声明一个变量 `const num = 1`，TS 会自动将变量的类型推断成 `number`，所以后面我们就可以对 `num` 变量使用 `number` 的一些操作方法。但是当使用联合类型的时候，`TS` 在编译阶段就无法得知当前的变量类型是什么，所以只可以使用共有的一些方法，所以我们需要使用类型保护的能力，比如可以通过一些判断来缩小当前变量或者断言当前变量的类型。

### typeof

`typeof` 是判断变量类型的一个操作符，我们可以通过`typeof`将类型缩小变成一个受保护的类型，如：

```tsx
const fn = (value: number | string): void => {
  value // value is number | string

  if (typeof value === 'number') {
    value // value is number
    value.toFixed // no error
  } else {
    value // value is string
    value.length // no error
  }
}
```

### instanceof

和 `typeof` 类似，`instanceof` 也是一个判断变量类型的方式，比如一个函数可以同时接收不同的普通的对象，就会导致 `typeof value === 'object'` 分辨不出来。就可以使用 `instanceof` 来辨别对象是什么。

### in

`in` 可以检查是否存在某个属性，如：

```tsx
type Item1 = {
  type: 'item1';
  name: string;
  age: number;
}

type Item2 = {
  type: 'item2',
  title: string;
  description: string;
}

const fn = (value: Item1 | Item2): void => {
  if ('name' in value) {
    value.age // no error
  } else {
    value.description // no error
  }
}
```

### 字面量判断

如上面的例子，如果后期对 `Item2`添加`name`属性就容易导致这里类型判断失效，导致获取 `value.age` 就会存在问题。所以针对上述这种存在 `type` 区分的情况，可以直接使用字面量判断。

```tsx
const fn = (value: Item1 | Item2): void => {
  if (value.type === 'item1') {
    value.age // no error
  } else if (value.type === 'item2') {
    value.description // no error
  }
}
```

### is 关键字自定义

使用上面的方法在简单的场景下是十分有效，但是有时候类型的判断是复杂的，或者这样的判断是通用的，所以为了避免重复的编写我们可能需要对这个类型的保护需要提取成函数，那么就可以使用 `is` 来进行指定。

---



## **类型断言**

> 有了类型断言我们可以轻松的迁移一个项目，但是类型断言是有害的，因为我们主动的给这个变量向 `TS` 类型检查器做了背书而不是通过类型保护的方式。所以假设传入的数据是有误的，就会导致运行异常，**所以我们需要谨慎的使用类型断言，除非可以 100% 的保证这里类型。**

### as 与 <>

有的时候 `TS` 的检验规则是存在缺陷的，不能完美的做好类型保护，比如下面的例子，**虽然我们已经提前判断过 `item.parent` 肯定不为空，但是在一个闭包环境中使用，由于 `TS` 的缺陷，类型还是失效了（因为我们是马上运行的）**。但是我们可以保证这里的类型肯定是不会为 `null` 的，所以我们就可以断言它的类型。

```tsx
interface Item {
  parent: Item | null;
}

const fn = (item: Item) => {
  if (!item.parent) {
    return;
  }
  const _fn = () => {
    item.parent // Item | null
    const parent1 = item.parent as Item;
    const parent2 = <Item>item.parent;
  }
  _fn();
}
```

### ! 非空断言

顾名思义，主要是排除变量中 `null` 和 `undefined` 的类型。比如上面提到的 `item.parent` 我们可以很清楚的知道他不是一个 `null` 的，就可以使用这个简单的方式。

```tsx
interface Item {
  parent: Item | null;
}

const fn = (item: Item) => {
  if (!item.parent) {
    return;
  }
  const _fn = () => {
    const p1 = item.parent.parent; // error: （item.parent）对象可能为 null
    const p2 = (<Item>item.parent).parent // ok，item.parent 整体断言
    const p3 =item.parent!.parent; // ok，item.parent 非空，则排除 null
  }
}
```



# **高级用法**

## **函数重载**

函数重载是静态类型语言当中很重要的一个能力。很多时候编写的函数可能会兼容多种参数类型，可能会根据传入的参数会返回不同的数据。比如：

```tsx
const data = { name: 'licy' };
const getData = (stringify: boolean = false): string | object => {
  if (stringify === true) {
    return JSON.stringify(data);
  } else {
    return data;
  }
}

const res1 = getData(); // string | object
const res2 = getData(true); // string | object
```

在上述的例子中调用 `getData` 方法得到一个联合了联合类型，还需要进行判断将类型缩小或者使用 `as` 进行指定。但是如果作为方法的编写者，当确定传入的参数后就可以很准确的得到返回值的类型，而不是得到这种模棱两可的情况。所以借助函数重载进行改造：

```tsx
const data = { name: 'licy' };
function getData(stringify: true): string
function getData(stringify?: false): object
function getData(stringify: boolean = false): unknown {
  if (stringify === true) {
    return JSON.stringify(data);
  } else {
    return data;
  }
}

const res1 = getData(); // object
const res2 = getData(true); // string
```

函数重载的使用方法很简单，就是在需要使用函数重载的地方，多声明几个函数的类型。然后在最后一个函数中进行实现，特别要注意的是，最后实现函数中的类型一定要与上面的类型兼容。

值得注意的是由于 `TS` 是在编译后会将类型抹去生成 `JS` 代码，而 `JS` 是没有函数重载这样的能力，所以说这里的函数重载只是类型的重载，方便做类型的提示，**实际上还是要在实现函数中进行传入参数的判别，然后返回不同的结果**。

## **泛型**

泛型是 `TS` 一个比较高级的用法，在日常的开发中也是使用比较多的。当你的函数，接口或者类需要支持多种类型的时候就可以使用泛型，比如上面函数重载的例子，也可以使用泛型进行改造。

```tsx
// 泛型函数
const data = { name: 'licy' };
function getData<T extends boolean = false, R = T extends true ? string : object>(stringify?: T): R {
  if (stringify === true) {
    return JSON.stringify(data) as unknown as R;
  } else {
    return data as unknown as R;
  }
}

const res1 = getData(); // object
const res2 = getData(true); // string

// 泛型类型
type ValueOf<T> = T[keyof T];

interface User {
  name: 'licy';
}

type A =  keyof User; // 'name'
type B = ValueOf<User>; // 'licy'
```

