## 设计模式原则

- S – Single Responsibility Principle 单一职责原则
  - 一个程序只做好一件事
  - 如果功能过于复杂就拆分开，每个部分保持独立
- O – OpenClosed Principle 开放/封闭原则
  - 对扩展开放，对修改封闭
  - 增加需求时，扩展新代码，而非修改已有代码
- L – Liskov Substitution Principle 里氏替换原则
  - 子类能覆盖父类
  - 父类能出现的地方子类就能出现
- I – Interface Segregation Principle 接口隔离原则
  - 保持接口的单一独立
  - 类似单一职责原则，这里更关注接口
- D – Dependency Inversion Principle 依赖倒转原则
  - 面向接口编程，依赖于抽象而不依赖于具体
  - 使用方只关注接口而不关注具体类的实现

##### SO体现较多，举个栗子：（比如Promise）

- 单一职责原则：每个then中的逻辑只做好一件事
- 开放封闭原则（对扩展开放，对修改封闭）：如果新增需求，扩展then



## [单例模式](https://juejin.cn/post/7150986499935666190#heading-1)

**定义：**

* 在《JavaScript设计模式与开发实践》 中对**单例模式**的定义为：
  * **保证一个类仅有一个实例，并提供一个访问它的全局访问点**。
  * **单例模式**属于是比较常用的设计模式，其一个主要用途是避免重复的创建实例，节约不必要的开销。
  * 通常会在第三方库的开发中使用到，如果是项目的开发，单例模式也会用在一些数据缓存、全局通用弹窗（如登录弹窗）等一些场景中。

**用例：**

* 标准的**单例模式**并不复杂，这里直接借用书中的一个例子：

  ```js
  var Singleton = function( name ){
      this.name = name;
      this.instance = null;
  };
  
  Singleton.prototype.getName = function(){
      alert ( this.name );
  };
  
  Singleton.getInstance = function( name ){
      if ( !this.instance ){
          this.instance = new Singleton( name );
      }
      return this.instance;
  };
  
  var a = Singleton.getInstance( 'sven1' );
  var b = Singleton.getInstance( 'sven2' );
  
  alert ( a === b ); // true
  ```

* 从这个例子中，很容易卡不到当执行`Singleton.getInstance`时：只有没有`instance`时才会执行初始化方法，后面再执行的时候会直接复用之前的`instance`，这就保证了即使函数执行了很多次，也能保证唯一实例。



### **惰性单例**

**定义：**惰性单例指的是在需要的时候才创建对象实例。通常会用在全局唯一且非必需的一些场景，例如：全局弹窗、购物车列表、全局共同信息等场景。拿书中登录弹窗的例子可以理解的更加清晰：

```js
var createLoginLayer = (function() {
    var div;
    return function() {
        if(!div) {
            div = document.createElement('div');
            div.innerHtml = '登录弹窗';
            div.style.display = 'none';
            document.body.appendChild(div);
        }
        return div;
    }
})()

document.getElementById('loginBtn').onclick = function() {
    var loginLayer = createLoginLayer();
    loginLayer.style.display = 'block';
}
```

在这个例子中，只有在登录按钮点击时，才会去创建**登录弹窗dom节点**，而不是在页面加载时就默认创建，并且，只有在第一次执行时创建**登录弹窗dom节点**，再次执行也不会创建多余的节点，节省了一部分性能。



## 观察者模式(发布订略模式)

**定义：**

一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。

```js
export default class events {
  constructor() {
    this.typesQueue = {};
  }

  // good
  emit(type, ...props) {
    if (this.queue.hasOwnProperty(type)) {
      this.queue[type].forEach(ele => {
        ele(...props);
      });
      return true;
    }
  }

  addListener(type, fun) {
    if (typeof fun !== 'function') {
      throw new Error('第二个参数应为函数类型');
    }
    //如果该监听类型不存在则建立该消息队列
    if (!this.typesQueue.hasOwnProperty(type)) {
      this.typesQueue[type] = [];
    }
    //插入该类型
    this.typesQueue[type].push(fun);
  }

  removeListener(type, fun) {
    if (this.typesQueue.hasOwnProperty(type)) {
      /* >>>代表无符号数右移，当查找到该方法右移0位没有影响，
        但是当没有查到时，结果为-1,-1的补码为11111...1(js底层为32进制)
        那么该补码转化为无符号数时已经远远超出数组的范围,并不会删除队列中的方法
      */
      this.eventMap[type].splice(this.eventMap[type].indexOf(fun) >>> 0, 1);
      // delete this.eventMap[type];
    }
  }
}
```



### 适配器模式

将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。

```js
class Plug {
  getName() {
    return 'iphone充电头';
  }
}

class Target {
  constructor() {
    this.plug = new Plug();
  }
  getName() {
    return this.plug.getName() + ' 适配器Type-c充电头';
  }
}

let target = new Target();
target.getName(); // iphone充电头 适配器转Type-c充电头
```



### 装饰者模式

- 动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案
- 在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象

```js
class Cellphone {
    create() {
        console.log('生成一个手机')
    }
}
class Decorator {
    constructor(cellphone) {
        this.cellphone = cellphone
    }
    create() {
        this.cellphone.create()
        this.createShell(cellphone)
    }
    createShell() {
        console.log('生成手机壳')
    }
}
// 测试代码
let cellphone = new Cellphone()
cellphone.create()

console.log('------------')
let dec = new Decorator(cellphone)
dec.create()
```

