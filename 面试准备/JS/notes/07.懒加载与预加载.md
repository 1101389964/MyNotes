## 懒加载

### 懒加载的意义（为什么要使用懒加载）

> 对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。

### 实现懒加载

```js
/*
原理:将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。
当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。
*/
<style>
    //图片需设置高度和宽度
      img {
        display: block;
        margin-bottom: 50px;
        width: 400px;
        height: 650px;
      }
</style>

<body>
  <img src="" data-src="https://img0.baidu.com/it/u=2637960104,2696565974&fm=26&fmt=auto" alt="">
  <img src=""
    data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fmobile%2F2020-03-17%2F5e70362d1a920.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648816146&t=2fb5c9c504b9f873f4ab09324735650a"
    alt="">
  <img src=""
    data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F005NWMakgy1gruks7tepij60yi22oarp02.jpg&refer=http%3A%2F%2Ftva1.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648816146&t=91be8ea118cb4c74e144558114ac386f"
    alt="">
  <img src=""
    data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fmobile%2F2020-10-13%2F5f85462dbbd64.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648816146&t=7d48e8aff0823391d11ebb1a46fe84c8"
    alt="">
  <img src=""
    data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp1.itc.cn%2Fimages01%2F20201221%2F7d672a01c77745b4a7f0b52dde9aab80.jpeg&refer=http%3A%2F%2Fp1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648816146&t=a3edf39f2f849c6dd4700d2a4d5c02f3"
    alt="">
</body>

<script>
  const imgs = document.querySelectorAll("img");
  //首先执行一次，否则没有滑动的情况下所有图片都没有请求加载。
  imgs.forEach((item) => {
    const top = item.getBoundingClientRect().top;
    if (top < window.innerHeight) {
      const url = item.getAttribute("data-src");
      item.src = url;
    }
  })
  window.addEventListener("scroll", (e) => {
    imgs.forEach((item) => {
      const top = item.getBoundingClientRect().top;//获取图片到窗口顶部的距离
      if (top < window.innerHeight) {//当图片到窗口顶部距离小于窗口高度时将src里的内容设置为data-src的值
        const url = item.getAttribute("data-src");//
        item.src = url;
      }
    })
  })
</script>
```

**缺点：**每次滚动都会触发事件，而且每次所有的图片DOM数组都会被遍历，性能较差。

### **使用IntersectionObserver内置对象进行优化**

```js
//使用IntersectionObserver内置对象,该对象可以在发现元素时触发一次，离开元素时触发一次
  const images = document.querySelectorAll("img");
  const callback = entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const image = entry.target;
        const data_src = image.getAttribute('data-src');
        image.src = data_src;
        observer.unobserve(image);//在发现元素之后取消监听
        console.log("触发");
      }
    })
  }
  const observer = new IntersectionObserver(callback);
  images.forEach(item => {
    observer.observe(item);
  });
```

## 

## 预加载

### 1.什么是预加载

资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。**预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源**。

### 2.为什么要用预加载

在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。

### 3.实现预加载的几种办法

- 使用HTML标签

```html
<img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/>
```

- 使用Image对象

```html
<script src="./myPreload.js"></script>
```

```js
//myPreload.js文件
var image= new Image()
image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg"
```

- 使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程

```js
var xmlhttprequest = new XMLHttpRequest();
xmlhttprequest.onreadystatechange = callback;
xmlhttprequest.onprogress = progressCallback;
xmlhttprequest.open("GET","http://image.baidu.com/mouse,jpg", true);
xmlhttprequest.send();
function callback(){
  if(xmlhttprequest.readyState == 4 && xmlhttprequest.status == 200){
    var responseText = xmlhttprequest.responseText;
  }else{
     console.log("Request was unsuccessful:" + xmlhttprequest.status);
  }
}
function progressCallback(e){
    e = e || event;
    if(e.lengthComputable){
    	console.log("Received" + e.loaded + "of" + e.total + "bytes")
    }
}
```

- 使用[PreloadJS库](https://link.juejin.cn?target=https%3A%2F%2Fcreatejs.com%2Fpreloadjs)

PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。

```js
//使用preload.js
var queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域
queue.on("complete",handleComplete,this);
queue.loadManifest([
{id:"myImage",src:"http://pic26.nipic.com/20121213/6168183  0044449030002.jpg"},
{id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526  1931471581702.jpg"}
]);
function handleComplete(){
  var image=queue.getResuLt("myImage");
  document.body.appendChild(image);
}
复制代码
```



## 懒加载和预加载的对比

两者都是提高页面性能有效的办法，**两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力**。



