## Hash模式路由

我们都知道一个URL是由很多部分组成，包括协议、域名、路径、query、hash等，比如下面的例子，我们点击不同模块的时候可能看到是这样的URL

- 首页：yourdomain.xxx.com/index.html/#/
- 商城：yourdomain.xxx.com/index.html/#/shop
- 购物车：yourdomain.xxx.com/index.html/#/shopping-cart
- 我的：yourdomain.xxx.com/index.html/#/mine

\#号后面的，就是一个URL中关于hash的组成部分，可以看到，不同路由对应的hash是不一样的，但是它们都是在访问同一个静态资源index.html。我们要做的，就是如何能够监听到URL中关于hash部分发生的变化，从而做出对应的改变。

其实浏览器已经暴露给我们一个现成的方法**hashchange**，在hash改变的时候，触发该事件。有了监听事件，且改变hash页面并不刷新，这样我们就可以在监听事件的回调函数中，执行我们展示和隐藏不同UI显示的功能，从而实现前端路由。

### **代码实现**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" name="viewport" />
    <title>实现简单的hash路由</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      #content {
        height: calc(100vh - 50px);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3em;
      }
      #nav {
        height: 50px;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        display: flex;
      }
      #nav a {
        width: 25%;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
      }
      #nav a:not(:last-of-type) {
        border-right: none;
      }
    </style>
  </head>
  <body>
    <main id="content"></main>
    <nav id="nav">
      <a href="#/">首页</a>
      <a href="#/shop">商城</a>
      <a href="#/shopping-cart">购物车</a>
      <a href="#/mine">我的</a>
    </nav>
  </body>
  <script>
    class VueRouter {
      constructor(routes = []) {
        this.routes = routes; // 路由映射
        this.currentHash = ''; // 当前的hash
        this.refresh = this.refresh.bind(this);
        // load 是第一次加载完成时调用refesh，否则内容区域会空白
        window.addEventListener('load', this.refresh, false);
        window.addEventListener('hashchange', this.refresh, false);
      }

      getUrlPath(url) {
        // 获取hash
        return url.indexOf('#') >= 0 ? url.slice(url.indexOf('#') + 1) : '/';
      }

      refresh(event) {
        // URL hash发生改变的时候，拿到当前的hash
        let newHash = '';
        if (event.newURL) {
          newHash = this.getUrlPath(event.newURL || '');
        } else {
          newHash = this.getUrlPath(window.location.hash);
        }
        this.currentHash = newHash;
        this.matchComponent();
      }

      matchComponent() {
        let curRoute = this.routes.find(route => route.path === this.currentHash);
        if (!curRoute) {
          // 当前URL中的hash不存在的时候，默认取第一个，当然真实场景下，可能会有各种情况，取决于业务逻辑
          curRoute = this.routes.find(route => route.path === '/');
        }
        const { component } = curRoute;
        document.querySelector('#content').innerHTML = component;
      }
    }

    const router = new VueRouter([
      {
        path: '/',
        name: 'home',
        component: '<div>首页内容</div>'
      },
      {
        path: '/shop',
        name: 'shop',
        component: '<div>商城内容</div>'
      },
      {
        path: '/shopping-cart',
        name: 'shopping-cart',
        component: '<div>购物车内容</div>'
      },
      {
        path: '/mine',
        name: 'mine',
        component: '<div>我的内容</div>'
      }
    ]);
  </script>
</html>

```

### **总结：**

* hash模式所有的工作都是在前端完成的，不需要后端服务的配合
* hash模式的实现方式就是通过监听URL中hash部分的变化，从而做出对应的渲染逻辑
* hash模式下，URL中会带有#，看起来不太美观



## History模式

history路由模式的实现，是要归功于HTML5提供的一个history全局对象，可以将它理解为其中包含了关于我们访问网页（历史会话）的一些信息。同时它还暴露了一些有用的方法，比如：

- `window.history.go` 可以跳转到浏览器会话历史中的指定的某一个记录页
- `window.history.forward` 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同
- `window.history.back` 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同
- `window.history.pushState` 可以将给定的数据压入到浏览器会话历史栈中
- `window.history.replaceState` 将当前的会话页面的url替换成指定的数据

而**history**路由的实现，主要就是依靠于`pushState`与`replaceState`实现的，这里我们先总结下它们的一些特点

- **都会改变当前页面显示的url，但都不会刷新页面**
- `pushState`是压入浏览器的会话历史栈中，会使得`history.length`加1，而`replaceState`是替换当前的这条会话历史，因此不会增加`history.length`

既然已经能够通过pushState或replaceState实现改变URL而不刷新页面，那么是不是如果我们能够监听到改变URL这个动作，就可以实现前端渲染逻辑的处理呢？这个时候，我们还要了解一个事件处理程序popstate，先看下它的[官方定义](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event)

这里我用大白话总结下就是以下几点

- `history.pushState`和`history.replaceState`方法是不会触发`popstate`事件的
- 但是浏览器的某些行为会导致`popstate`，比如`go、back、forward`
- `popstate`事件对象中的`state`属性，可以理解是我们在通过`history.pushState`或`history.replaceState`方法时，传入的指定的数据

说了一大堆，结果却是popstate无法监听history.pushState和history.replaceState方法，这不是扯呢吗？那好吧，既然你厂商没实现此功能，那么我自己重新写下你这个history.pushState和history.replaceState方法吧，让你在这个方法中，也能够暴露出自定义的全局事件，然后我再监听自定义的事件，不就行了？

**自义定事件：**

```js
let _wr = function(type) {
   let orig = history[type]
   return function() {
      let rv = orig.apply(this, arguments)
      let e = new Event(type)
      e.arguments = arguments
      window.dispatchEvent(e)
      return rv
   }
}

 history.pushState = _wr('pushState')
 history.replaceState = _wr('replaceState')
```

执行完上面两个方法后，相当于将pushState和replaceState这两个监听器注册到了window上面，具体的定义可参考[EventTarget.dispatchEvent](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FEventTarget%2FdispatchEvent)

### **代码实现**

### <img src="Untitled.assets/173f92132d0a4b1587d70b384c46222btplv-k3u1fbpfcp-zoom-in-crop-mark3024000.awebp" alt="img" style="zoom: 50%;" />

### **重点**

**hash模式是不需要后端服务配合的。但是history模式下，如果你再跳转路由后再次刷新会得到404的错误，这个错误说白了就是浏览器会把整个地址当成一个可访问的静态资源路径进行访问，然后服务端并没有这个文件**～看下面例子更好理解

**没刷新时，只是通过pushState改变URL，不刷新页面**

```tex
http://192.168.30.161:5500/ === http://192.168.30.161:5500/index.html // 默认访问路径下的index.html文件，没毛病
http://192.168.30.161:5500/home === http://192.168.30.161:5500/index.html // 仍然访问路径下的index.html文件，没毛病
...
http://192.168.30.161:5500/mine === http://192.168.30.161:5500/index.html // 所有的路由都是访问路径下的index.html，没毛病
```

**一旦在某个路由下刷新页面的时候，想当于去该路径下寻找可访问的静态资源index.html，无果，报错**

```tex
http://192.168.30.161:5500/mine === http://192.168.30.161:5500/mine/index.html文件，出问题了，服务器上并没有这个资源，404😭
```

**所以一般情况下，我们都需要配置下nginx，告诉服务器，当我们访问的路径资源不存在的时候，默认指向静态资源index.html**



### **总结**：

* 一般路由实现主要有**history**和**hash**两种方式
* **hash**的实现全部在前端，不需要后端服务器配合，兼容性好，主要是通过监听**hashchange**事件，处理前端业务逻辑
* **history**的实现，**需要服务器做以下简单的配置**，通过监听**pushState**及**replaceState**事件，处理前端业务逻辑



