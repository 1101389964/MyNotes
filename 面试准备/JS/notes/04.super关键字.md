## super 作为函数调用

1. 当`super` 作为函数调用时, 它代表的指向的是父类的构造函数,在子类的构造函数必须执行一次 super 函数，也就是说,在子类继承父类中，如果`super`作为函数调用，只能写在子类的构造函数(constructor)里面，`super`代表的是父类的构造函数
2. 在执行`super`时，A 把 constructor 方法给了 B，此时 B 有了 A 的功能，但是执行的是 B 的内容，也就是 es5 的`A.prototype.constructor.call(this)`
3. 作为函数调用:它必须只能在子类的构造器函数(constructor)中进行调用的，而且必须在this调用之前使用，如果放在其他地方,则是会报错



## super 作为对象使用

`super`作为对象使用时，分为在**普通方法中使用**和在**静态方法中使用**

### **普通方法使用**:

* **`super`指向父类的原型,即`A.prototype`,可以访问到原型上的方法和属性,也就是指向它父类的原型对象**

```js
class Animal {     // class关键字声明了一个Animal类
    constructor() {
    }
    parent(){  // 类Animal的一个方法
        console.log('我是父类Animal的普通方法... ...');
    }
}

class Dog extends Animal {   // class关键字定义了Dog继承自Animal类
    constructor() {
        super()
    }
   watchHome(){            // 子类watchHome为Dog的方法
       super.parent() // 等价于Animal.prototype.parent() 
   }
}
const dog = new Dog()
dog.watchHome()

```

**注意**：由于 super 指向父类的原型对象, 所以定义在子类实例上的方法或属性, 是无法通过super 调用的

* **在子类普通方法中, 通过 `super` 调用父类的方法时, 方法内部的 `this` 指向当前子类的实例.**

  ```js
  class A {
    constructor() {
      this.name = "itclanCoder";   // 定义在A类的私有属性
    }
    print() {   // 定义在A类的print私有方法
      console.log(this.name);
    }
  }
  
  class B extends A {  // 类B继承自类A
    constructor() {
      super();         // 调用父类的super
      this.name = "随笔川迹";     // 子类B的私有属性
    }
    m() {
      super.print();
    }
  }
  
  let b = new B();
  b.m() // 随笔川迹
  /* super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类 B 的实例
  导致输出的是"随笔川迹"，而不是"itclanCoder"。也就是说，实际上执行的是super.print.call(this) */
  ```

**如果用在静态方法之中**

* **如果 `super`作为对象,用在静态方法之中,这时`super`将指向父类 , 而不是父类的原型对象**

* ```js
  class Parent {
      static myMethod(msg) {  // 父类的方法之前加静态static关键字
          console.log('static1', msg);
      }
  
      myMethod(msg) {            // 父类的私有普通方法
          console.log('instance2', msg);
      }
  }
  
  class Child extends Parent {  // 类child继承自篇Parent
      static myMethod(msg) {    // 子类的私有myMethod方法前声明static
          super.myMethod(msg); // super在静态方法中指向父类, 而不是父类的原型
      }
  
      myMethod(msg) {
          super.myMethod(msg); // super在普通方法中指向父类的原型
      }
  }
  
  Child.myMethod(1); // static1 1
  
  var child = new Child();
  child.myMethod(2); // instance2 2
  ```

* **在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类而不是子类的实例**

* ```js
  class A {
    constructor() {
      this.x = 1;
    }
    static print() {
      console.log(this.x);
    }
  }
  
  class B extends A {
    constructor() {
      super();
      this.x = 2;
    }
    static m() {
      super.print();
    }
  }
  
  B.x = 3;
  B.m() // 3
  ```