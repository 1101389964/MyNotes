# 多维数组的扁平化

```js
const arr = [1, [2, 3, 4, 5], [6, 7, 8, 9, [10, 11, 12, [14, 15, 16]]]]; 
const newArr = [];
```

### 递归

```js
// 一,递归
const getArr = (array) => {
    array.forEach((item)=>{
        // 如果遍历的元素不是一个数组 就把这个元素放到新数组中
        // 反之就进行递归再次调用方法
        Array.isArray(item) ? getArr(item) : newArr.push(item)
    })
}
getArr(arr);
```

### 迭代

```js
function getArr(nums) {
	nums.forEach(ele => {
    if (ele instanceof Array) {
        getArr(ele);
    }else {
      newArr.push(ele);
    }
  })
}
getArr(nums);
```

### 将多维数组转为字符串，再转化为一维数组

```js
// join转为字符串，split转为数组，map字符串Number化
arr.join(',').split(',').map(ele => parseInt(ele));
```

### 结合 Infinity 使用 [flat](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)

```js
//使用 Infinity，可展开任意深度的嵌套数组
arr.flat(Infinity);
```



# 对象的深浅拷贝

```js
var obj = {
  info: {
    name: '张三'
  },
  age: 23
}
```

## 浅拷贝

### 1.迭代

```js
function shallowCopy(obj) {
  const res = typeof obj === 'object' ? {} : [];
  for (let key in obj) {
    if (origin.hasOwnProperty(key)) {
      res[key] = obj[key];
  	}
  return res
}
```

### 2.assign方法

```js
function shallowCopy(obj) {
  // assign将obj对象的属性浅合并到第一个参数中，对于多层对象，只是将对象的引用拷贝过来了。
  const res = Object.assign({}, obj)
  return res
}
```

## 深拷贝

### 1.JSON.stringify与JSON.parse

```js
//这个方法有一些弊端:在JSON序列化时会忽略undefined function Symbol，而Map/Set/WeakMap/WeakSet则会被序列化成可枚举的属性
function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj))
}

// 包含循环引用的对象会报错 对象之间相互引用 形成无限循环
var data = {
    name: 'foo',
    child: null
}
data.child = data
var data2 = JSON.stringify(JSON.parse(data)) // 报错
```

### 2.递归+迭代

```js
// 迭代+递归
function deepClone(origin, target) {
  var target = target || {},
    toStr = Object.prototype.toString,
    isArr = '[object Array]';

  for (var key in origin) {
    // 排除原型链上的对象
    if (origin.hasOwnProperty(key)) {
      // 若属性的值为引用类型
      if (typeof origin[key] === 'object' && origin[key] !== null) {
        // 为数组还是对象，也可以使用 instanceof
        target[key] = toStr.call(origin[key]) === isArr ? [] : {}
        deepClone(origin[key], target[key])
      } else {
        target[key] = origin[key]
      }
    }
  }

  return target;
}
// 使用instanceof
function deepClone(origin, target) {
  target = target === undefined ? {} : target;

  for (let key in origin) {
    if (origin.hasOwnProperty(key)) {
      if (typeof origin[key] === 'object' && origin[key] !== null) {
        if (origin[key] instanceof Object) {
          target[key] = {}
          deepClone(origin[key], target[key])
        } else {
          target[key] = []
          deepClone(origin[key], target[key])
        }
      } else {
        target[key] = origin[key]
      }
    }
  }

  return target
}
```



