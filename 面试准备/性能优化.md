[原文](https://juejin.cn/post/6892994632968306702)

## 一、网络优化

### 1、将多个小文件合并为一个大文件，减少 HTTP 请求

一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。接下来看一个具体的例子帮助理解 HTTP ：

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c1c42e60734ecd8dc7db8f4a8443ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这是一个 HTTP 请求，请求的文件大小为 28.4KB。

名词解释：

- Queueing: 在请求队列中的时间。
- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。
- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。
- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。
- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。
- SSL: 完成SSL握手所花费的时间。
- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。
- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。
- Content Download: 接收响应数据所花费的时间。

从这个例子可以看出，真正下载数据的时间占比为 `13.05 / 204.16 = 6.39%`，**文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。**

### 2、使用 HTTP2

HTTP2 相比 HTTP1.1 有如下几个优点：

1. 解析速度快
2. 多路复用
3. HTTP2 提供了首部压缩功能。
4. 优先级：HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。
5. 流量控制：当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。
6. 服务器推送：HTTP2 除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。



### 3、静态资源使用 CDN

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。



### 4、善用缓存，不重复加载相同的资源

为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。





## 二、代码优化

### 1、将 CSS 放在文件头部，JavaScript 文件放在底部

- CSS 执行会阻塞渲染，阻止 JS 执行
- JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建

 **如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。**

**那为什么 CSS 文件还要放在头部呢？**

* **因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。**

另外，J**S 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了**，异步下载，延迟执行。



### 2、使用字体图标 iconfont 代替图片图标

字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。



### 3、使用图片懒加载

在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

详情见懒加载笔记



### 4、使用事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。



### 5、查找表map

当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。



### 6.使用位操作

JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。

##### 取模

由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。

```js
if (value % 2) {
	// 奇数
} else {
	// 偶数 
}
// 位操作
if (value & 1) {
	// 奇数
} else {
	// 偶数
}
复制代码
```

##### 取整

```js
~~10.12 // 10
~~10 // 10
~~'1.5' // 1
~~undefined // 0
~~null // 0
复制代码
```

##### 位掩码

```js
const a = 1
const b = 2
const c = 4
const options = a | b | c
复制代码
```

通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。

```js
// 选项 b 是否在选项中
if (b & options) {
	...
}
```



### 7、 不要覆盖原生方法

无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。



### 8、使用 flexbox 而不是较早的布局模型

在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 [flexbox](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2FCSS_Flexible_Box_Layout%2FBasic_Concepts_of_Flexbox)，它比起早期的布局方式来说有个优势，那就是性能比较好。



## 三、webpack优化

### 1、压缩文件

​	详情见webpack性能优化篇章

* **压缩js文件**：可以帮助我们压缩、丑化我们的代码，让我们的bundle变得更小

* ```js
  const TerserPlugin = require("terser-webpack-plugin"); //webpack5已经自带了terser，只需要引入即可
  
  module exports = {
    // 优化
    optimization: {
      minimize: true,// 当为true时minimizer会执行，为false则不会执行
      minimizer: [
         new TerserPlugin({
  		parallel: true,// 使用多进程并发运行以提高构建速度,为true时并发运行的默认数量:os.cpus().length-1，cpu多核数量减一
           extractComments: false,// 是否将注释剥离到单独的文件中,开启为true。
           terserOptions: { // terser的配置项
  		  mangle: true,
             toplevel: true,
             keep_classnames: true,
             keep_fnames: true
           }
         })
      ],
      splitChunks: {
        //async处理异步的导入
        //inital对同步的导入进行处理
        chunks: "all", //不管异步导入还是同步导入都会抽取公共的依赖为单独的配置文件。
      },
  } 
  ```

* **CSS压缩**

  **CSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等；** 
  CSS的压缩我们可以使用另外一个插件：`css-minimizer-webpack-plugin`； 
  css-minimizer-webpack-plugin是使用cssnano工具来优化、压缩CSS（也可以单独使用）；

  **前提**：

  得使用**min-css-extract-plugin**单独把css文件打包，然后进行压缩。

  **安装：**`npm install css-minimizer-webpack-plugin -D`

  **配置**：

  ```js
  const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
  
  plugins:[
      new CssMinimizerPlugin(),
  ]
  ```

* **HTML压缩：**

  `HtmlWebpackPlugin`，由于html页面一般时空白的，只有一个根标签相当于注入，所以优化带来的益处较少
  
* **使用Tree Shaking**

  * 参考webpack性能优化篇章。



### 2、减少 ES6 转为 ES5 的冗余代码

Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如：

```js
class Person {}
复制代码
```

会被转换为：

```js
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Person = function Person() {
  _classCallCheck(this, Person);
};
复制代码
```

这里 `_classCallCheck` 就是一个 `helper` 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 `helper` 函数。

这里的 `@babel/runtime` 包就声明了所有需要用到的帮助函数，而 `@babel/plugin-transform-runtime` 的作用就是将所有需要 `helper` 函数的文件，从 `@babel/runtime包` 引进来：

```js
"use strict";

var _classCallCheck2 = require("@babel/runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var Person = function Person() {
  (0, _classCallCheck3.default)(this, Person);
};
复制代码
```

这里就没有再编译出 `helper` 函数 `classCallCheck` 了，而是直接引用了 `@babel/runtime` 中的 `helpers/classCallCheck`。

**安装**

```bash
npm i -D @babel/plugin-transform-runtime @babel/runtime
复制代码
```

**使用** 在 `.babelrc` 文件中

```perl
"plugins": [
        "@babel/plugin-transform-runtime"
]
```

