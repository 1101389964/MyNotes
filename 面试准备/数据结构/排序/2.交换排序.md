## 冒泡排序

**基本思想**: 每趟不断将记录两两比较，并按“前小后大”规则交换。

**时间复杂度：**O(n2)

```js
for (let i = numbs.length - 1; i > 0; i--) {
        for (let j = 0; j < i; j++) {
            if (numbs[j] > numbs[j + 1]) {
                const temp = numbs[j];
                numbs[j] = numbs[j + 1];
                numbs[j + 1] = temp;
            }
        }
    }
```



## [快速排序](https://blog.csdn.net/qq_40941722/article/details/94396010?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166186590716781683976456%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166186590716781683976456&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-94396010-null-null.142^v42^pc_rank_34,185^v2^control&utm_term=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187)

**基本思想：**

* 任取一个元素(如:第一个)为中心
* **所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表**;
* **对各子表重新选择中心元素并依此规则调整**；

**代码：**

```js
function Quick_Sort(arr, begin, end){
    if(begin >= end) return;
    const flag = arr[begin];
    let i = begin, j = end;
    while (i < j) {
        /* 
        由于是已右边为基准的，所以必须从左边开始， 
        如果从右边开始当遍历到 i = j 的位置可能当前的值并不是 <= flag 的值,
        但还是会进行交换。
        */
        while(arr[j] >= flag && j > i) {
            j--;
        }
        while(arr[i] <= flag && j > i) {
            i++;
        }
        // 交换
        const temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    // 与基准位置交换，左边全是 <= 基准，右边都是 >= 基准
    arr[begin] = arr[i]; 
    arr[i] = flag;

    Quick_Sort(arr, begin, i-1);
    Quick_Sort(arr, i+1, end);
}  
```

