## 传输层

### 传输层的功能

1. **传输层提供进程与进程之间的通信。**

   如何理解:网络层是为主机与主机之间进行通信，那么当数据到达网络层时，只是数据进入到了主机，并没有进入到应用进程里面，才能实现通信。而网络层就是连接主机与进程之间的通信的，所以说**传输层提供进程与进程之间的通信**。
   
2. **复用和分用**

   1. **复用**：**应用层所有的应用进程都可以通过传输层再传输到网络层。**两个进程A与进程B的消息发送出去，会将两个进程的数据进行同一个传输单元进行传递，这就是**复用**。
   2. **分用：**  **传输层从网络层收到数据后交付指明的应用进程** ，另一台接收的主机需要将接收到的消息（报文段）传输给对应的进程，这就是分用。

3. **传输层会对报文进行差错检错**

4. **传输层的两种协议**：TCP、UDP

---

## TCP与UDP对比

* **TCP:**	面向连接的传输协议TCP
  * 传输数据之前必须建立连接，数据传送结束后要释放连接。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器、定时器及连接管理。
* **UDP:**  无连接的数据报协议UDP
  * 传输数据之前不需要建立连接，收到UDP报文之后也不需要给出任何的确认。
* **总结：**
  * TCP是可靠，面向连接，时延大，适用于大文件
  * UDP不可靠，无连接，时延小，使用与小文件

---

### TCP

#### TCP的特点

1. **TCP是面向连接**（虚连接)的传输层协议。
2. **TCP面向字节流**。=>TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。
3. **TCP连接是点对点的**。
4. **TCP提供可靠交付的**，无差错、不丢失、不重复、按序到达。可靠有序，不丢不重。
5. **TCP提供全双工通信**。//发送方与接收方可以同时发送数据也可以同时接收数据。
   1. 发送缓存：准备发送的数据&已发送但尚未收到确认的数据
   2. 接收缓存：按序到达但尚未被接受应用程序读取的数据&不按序到达的数据



#### TCP报文格式

<img src="image-20220305165059061.png" alt="image-20220305165059061" style="zoom: 67%;" />

* **源端口和目的端口**: 分别占用16位，**用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；**
* **序号（seq）**[seqence]:在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。
* **确认号（ack）**[acknowledgement]:期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。
* **数据偏移**（首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远,以4B位单位，即1个数值是4B。
* **6个控制位**：
  * **同步位 SYN**[synchronization]:**只有在请求连接和接收请求连接才为1**，表明是一个**连接请求/连接接受**报文。
  * **确认位 ACK**:ACK=1时确认号有效，**在连接建立后所有传送的报文段都必须把ACK置为1。**
  * **终止位 FIN**:FIN=1时，表明此报文段发送方数据已发完，要求**释放连接**。
  * 紧急位 URG: URG=1时，标明此报文段中有紧急数据，是**高优先级的数据**，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
  * 推送位 PSH:PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。
  * 复位 RST:RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。
* 窗口:指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。
* 检验和:检验首部+数据，检验时要加上12B伪首部，第四个字段为6。
* 紧急指针: URG=1时才有意义，指出本报文段中紧急数据的字节数。
* 选项:最大报文段长度MSs、窗口扩大、时间戳、选择确认.…

### TCP的三次握手

* 三次握手<img src="image-20220305170313297.png" alt="image-20220305170313297" style="zoom:67%;" />

* **为什么要三次握手**

  假设发送方为A，接收方为B，那为什么在A发送请求连接和B发送接收连接之后还要发送一次确认呢?

  > 1、这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。
  > 所谓“已失效的连接请求报文段”是这样产生的。考虑一种异常情况。A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。现假定出现异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。由于现在A并没有发出建立连接的请求，因此不会理睬B的确认。假定不采用三次握手，那么只要B发出确认，新的连接就建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。采用三次握手的办法可以防止上述现象的发生。
  >
  >  
  >
  > 2、第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。
  

### TCP的四次分手

<img src="image-20220305172324472.png" alt="image-20220305172324472" style="zoom:67%;" />

* **为什么要四次分手**

  > TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，主机1再回复确认，之后彼此就会愉快的中断这次TCP连接。
  
* **为什么需要等待2MSL秒**

  如果客户端最后回传的一个确认报文丢失没有到达服务器，那么服务器等待超时之后会再次发送一个链接释放报文给客户端。如果客户端没有设置等待2MSL，那么客户端在发送确认报文之后就已经关闭TCP连接了，就不会再接受连接释放报文了，就造成了服务器一直重复发送连接释放报文。

---

### SYN洪泛攻击

> **SYN洪泛攻击是利用TCP协议的特性，就是三次握手。攻击者发送TC SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机。**

---

### TCP可靠传输

tcp的客户端与服务器分别维护两个缓存[**发送缓存**，**接收缓存**]。

1. **发送缓存**：准备发送的数据&已发送但尚未收到确认的数据
2. **接收缓存**：按序到达但尚未被接受应用程序读取的数据&不按序到达的数据

**只有收到对方的ack确认为才会删除缓存中的字节流，如果接收方没有接受到期望的seq序列，会一直发送期望收到的ack序列来，发送方期间不会删除缓存中为被确认的字节流**。<br><img src="01.TCP.assets/image-20220924172032076.png" alt="image-20220924172032076" style="zoom:50%;" />

---

### **TCP流量控制**

TCP的流量控制通过滑动窗口来控制的。

在通信过程中，**接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小**，即接收窗口**rwnd** (接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。<br><img src="01.TCP.assets/image-20220925111348456.png" alt="image-20220925111348456" style="zoom: 50%;" />

### TCP拥塞控制

* **什么是拥塞控制**
  * 当网络中资源总和大于可用资源时，网络就会出现资源供应不足，然后网络性能变差，然后网络性能就随负荷增大而下降。而拥塞控制就是防止过多的数据注入的网络中。
* **拥塞控制与流量控制区别：**
  * 拥塞控制和流量控制都是接受带宽有限，需要发送方改变发送速率的方法。但是拥塞控制是全局性（一对多）的问题，而流量控制是点到点的问题。打个比方：<br><img src="01.TCP.assets/image-20220925112930912.png" alt="image-20220925112930912" style="zoom:50%;" /><br>拥塞控制接受方只有一个，但是发送发有多个，这时候链路上发送数据过多造成了拥塞，但是接收方并不知道是哪个发送发造成的，而流量若出现拥塞情况，发送发则会知道，这属于点到点的问题。
* **如何做到拥塞控制**
  * TCP 通过维护一个拥塞窗口来进行拥塞控制，拥塞控制的**原则是只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。**
  * **慢开始和拥塞避免**，当遇到网络拥堵时，再次从1个报文慢开始，只不过这次的新ssthresh的值不再是16，而是网络拥堵时的24 / 2 = 12，所以慢开始到12就开始采用加法增大了。<br>![image-20220925134940200](01.TCP.assets/image-20220925134940200.png)
  * **快重传和快恢复**，当收到3个重复的确认执行（意味着某条报文没有传到接收端）快重传算法，快重传是从当前的拥塞值除以2开始传而不知直接到0开始。<br>![image-20220925135142180](01.TCP.assets/image-20220925135142180.png)