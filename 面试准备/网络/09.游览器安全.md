## [原文](https://juejin.cn/post/6844903781704925191)

## XSS攻击

### 什么是 XSS

> `Cross-Site Scripting`（跨站脚本攻击）简称 XSS，是一种**代码注入攻击**。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 `Cookie`、`SessionID` 等，进而危害数据安全。

### XSS 攻击的分类

根据攻击的来源，XSS 攻击可分为**存储型**、**反射型**和 **DOM 型**三种。

#### 存储型 XSS

* 存储型 XSS 的攻击步骤：
  1. 攻击者将恶意代码提交到目标网站的数据库中。
  2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
  3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
* 存储型 XSS(又被称为持久性XSS)攻击常见于**带有用户保存数据的网站功能**，如论坛发帖、商品评论、用户私信等。
* 它**是最危险的一种跨站脚本**，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为**它不需要用户手动触发**。**任何允许用户存储数据的web程序都可能存在存储型XSS漏洞**，当攻击者提交一段XSS代码后，被服务器端接收并存储，当**所有浏览者访问某个页面时都会被XSS**。

#### 反射型 XSS

* 反射型 XSS 的攻击步骤：
  1. 攻击者构造出特殊的 URL，其中包含恶意代码。
  2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
* 反射型 XSS 跟存储型 XSS 的区别是：**存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。**
* 反射型 XSS (也被称为非持久性XSS)漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

#### DOM 型 XSS

* DOM 型 XSS 的攻击步骤：
  1. 攻击者构造出特殊的 URL，其中包含恶意代码。
  2. 用户打开带有恶意代码的 URL。
  3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
* DOM 型 XSS 跟前两种 XSS 的区别：**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。**

#### **对比:**

|    类型    |           存储区            |   插入点   |
| :--------: | :-------------------------: | :--------: |
| 存储型 XSS |         后端数据库          |    HTML    |
| 反射型 XSS |             URL             |    HTML    |
| DOM型 XSS  | 后端数据库/前端存储/URL前端 | JavaScript |

### 防御XSS攻击

#### 常用防范方法

* **httpOnly:** 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。
* **输入过滤:** 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。
* **转义 HTML:** 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善.想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库.(可以看下这个[库](https://link.juejin.cn/?target=https%3A%2F%2Fjsxss.com%2Fzh%2Findex.html),还是中文的)
* **白名单:** 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

----

## CSRF 跨站点请求伪造

### 什么是 CSRF

> 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:**攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。**

### CSRF攻击流程

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738264eeda674696989fc7b71c80c152~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="简而言之：网站过分相信用户" style="zoom: 80%;" />

从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：

- 1.登录受信任网站A，并在本地生成Cookie。
- 2.在不登出A的情况下，访问危险网站B。

### CSRF攻击类型

* **GET类型**的CSRF

  * 需要一个HTTP请求，一般会这样利用：` <img src="http://bank.example/withdraw?amount=10000&for=hacker" > `，在受害者访问含有这个img的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。

* **POST类型**的CSRF

  * 这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：

    ```html
     <form action="http://bank.example/withdraw" method=POST>
        <input type="hidden" name="account" value="xiaoming" />
        <input type="hidden" name="amount" value="10000" />
        <input type="hidden" name="for" value="hacker" />
    </form>
    <script> document.forms[0].submit(); </script> 
    ```

  * 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

* **链接类型的CSRF**

  * 这种需要用户点击链接才会触发。攻击者通常会以比较夸张的词语诱骗用户点击，例如：`<a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank"> 重磅消息！ <a/>`

### CSRF的特点

* 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
* 攻击**利用受害者在被攻击网站的登录凭证，冒充受害者提交操作**；而不是直接窃取数据。
* 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
* 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

### 防御

* **验证码；强制用户必须与应用进行交互，才能完成最终请求**。此种方式能很好的遏制 csrf，但是用户体验比较差。
* Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。
* token；**token 验证的 CSRF 防御机制是公认最合适的方案。**(具体可以查看本系列前端鉴权中对token有详细描述)**若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。**

## CSRF与 XSS 区别

- **通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。**
- 本质上讲，XSS 是代码注入问题，**CSRF 是 HTTP 问题。** XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。**CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。**

